---
title: "Component Helper"
description: "Compose and flatten React component wrappers with the FlatComponentHelper utility."
---

The `FlatComponentHelper` utility helps you compose multiple wrapper components in a clean and reusable way.

## Basic Usage

```tsx
import { FlatComponentHelper } from "rpress/helper";

export default function Page() {
  const helper = new FlatComponentHelper();

  // Add wrapper components
  helper.add(ErrorBoundary, { fallback: <ErrorFallback /> });
  helper.add(ThemeProvider, { theme: "dark" });
  helper.add(UserProvider, { userId: "123" });

  // Create composed wrapper
  const Wrapper = helper.flatten();

  return (
    <Wrapper>
      <div>Content wrapped by all providers</div>
    </Wrapper>
  );
}
```

## Static Composition

Use the static `compose` method for cleaner syntax:

```tsx
import { FlatComponentHelper } from "rpress/helper";

export default function App() {
  const helper = FlatComponentHelper.compose([
    { component: ErrorBoundary, props: { fallback: <div>Error!</div> } },
    { component: AuthProvider, props: { apiKey: "key123" } },
    { component: ThemeProvider, props: { theme: "light" } },
  ]);

  const AppWrapper = helper.flatten();

  return (
    <AppWrapper>
      <Router />
    </AppWrapper>
  );
}
```

## Provider Composition

Compose multiple context providers:

```tsx
import { FlatComponentHelper } from "rpress/helper";

// Define your providers
function AuthProvider({ children, config }) {
  return <AuthContext.Provider value={config}>{children}</AuthContext.Provider>;
}

function ThemeProvider({ children, theme }) {
  return (
    <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>
  );
}

export default function Layout({ children }) {
  const helper = new FlatComponentHelper();

  helper.add(AuthProvider, { config: authConfig });
  helper.add(ThemeProvider, { theme: "dark" });
  helper.add(ErrorBoundary, { fallback: <ErrorPage /> });

  const Providers = helper.flatten();

  return (
    <Providers>
      <div className="app-layout">
        <Header />
        <main>{children}</main>
        <Footer />
      </div>
    </Providers>
  );
}
```

## Conditional Wrappers

Add components conditionally:

```tsx
import { FlatComponentHelper } from "rpress/helper";

export default function ConditionalWrappers({ user, isDev }) {
  const helper = new FlatComponentHelper();

  // Always add error boundary
  helper.add(ErrorBoundary, { fallback: <ErrorFallback /> });

  // Add auth provider if user exists
  if (user) {
    helper.add(AuthProvider, { user });
  }

  // Add dev tools in development
  if (isDev) {
    helper.add(DevToolsProvider, { enabled: true });
  }

  const Wrapper = helper.flatten();

  return (
    <Wrapper>
      <MainApp />
    </Wrapper>
  );
}
```

## Route-Specific Wrappers

Create different wrapper compositions for different routes:

```tsx
import { FlatComponentHelper } from "rpress/helper";

export function createRouteWrapper(routeType: "public" | "private" | "admin") {
  const wrappers = [
    { component: ErrorBoundary, props: { fallback: <ErrorPage /> } },
    { component: ThemeProvider, props: { theme: "light" } },
  ];

  if (routeType === "private" || routeType === "admin") {
    wrappers.push({
      component: AuthProvider,
      props: { requireAuth: true },
    });
  }

  if (routeType === "admin") {
    wrappers.push({
      component: AdminProvider,
      props: { requireAdmin: true },
    });
  }

  const helper = FlatComponentHelper.compose(wrappers);
  return helper.flatten();
}

// Usage in routes
export default function PublicPage() {
  const Wrapper = createRouteWrapper("public");

  return (
    <Wrapper>
      <PublicContent />
    </Wrapper>
  );
}

export default function AdminPage() {
  const Wrapper = createRouteWrapper("admin");

  return (
    <Wrapper>
      <AdminDashboard />
    </Wrapper>
  );
}
```

## HOC Pattern

Create reusable higher-order components:

```tsx
import { FlatComponentHelper } from "rpress/helper";

export function withProviders<T extends Record<string, any>>(
  Component: React.ComponentType<T>,
  providers: Array<{
    component: React.ComponentType<any>;
    props?: Record<string, any>;
  }>,
) {
  return function WrappedComponent(props: T) {
    const helper = FlatComponentHelper.compose(providers);
    const Wrapper = helper.flatten();

    return (
      <Wrapper>
        <Component {...props} />
      </Wrapper>
    );
  };
}

// Usage
const MyPageWithProviders = withProviders(MyPage, [
  { component: AuthProvider, props: { apiKey: "key" } },
  { component: ThemeProvider, props: { theme: "dark" } },
]);
```

## Error Boundary Composition

Compose multiple error boundaries with different configurations:

```tsx
import { FlatComponentHelper } from "rpress/helper";

export default function RobustApp() {
  const helper = new FlatComponentHelper();

  // Global error boundary
  helper.add(GlobalErrorBoundary, {
    fallback: <GlobalErrorPage />,
    onError: (error) => logError(error),
  });

  // Network error boundary
  helper.add(NetworkErrorBoundary, {
    fallback: <NetworkErrorPage />,
    retryButton: true,
  });

  // Component-specific error boundary
  helper.add(ComponentErrorBoundary, {
    fallback: <ComponentErrorMessage />,
  });

  const ErrorBoundaries = helper.flatten();

  return (
    <ErrorBoundaries>
      <App />
    </ErrorBoundaries>
  );
}
```

## Performance Optimization

Cache composed wrappers to avoid recreation:

```tsx
import { FlatComponentHelper } from "rpress/helper";

const cachedWrappers = new Map();

export function getCachedWrapper(key: string, wrappers: Array<any>) {
  if (!cachedWrappers.has(key)) {
    const helper = FlatComponentHelper.compose(wrappers);
    cachedWrappers.set(key, helper.flatten());
  }
  return cachedWrappers.get(key);
}

export default function OptimizedPage() {
  const Wrapper = getCachedWrapper("main-layout", [
    { component: AuthProvider, props: { config: authConfig } },
    { component: ThemeProvider, props: { theme: "light" } },
  ]);

  return (
    <Wrapper>
      <PageContent />
    </Wrapper>
  );
}
```

## Best Practices

1. **Order matters**: Components are wrapped in the order they're added (first added wraps last added)
2. **Keep it simple**: Don't over-compose; use only necessary wrappers
3. **Cache when possible**: Avoid recreating wrappers on every render
4. **Type safety**: Ensure prop types are correct for each wrapper component

```tsx
// Good: Clear order and purpose
const helper = FlatComponentHelper.compose([
  { component: ErrorBoundary, props: { fallback: <Error /> } }, // Outermost
  { component: AuthProvider, props: { user } }, // Middle
  { component: ThemeProvider, props: { theme } }, // Innermost
]);

// Result: <ErrorBoundary><AuthProvider><ThemeProvider>children</ThemeProvider></AuthProvider></ErrorBoundary>
```
