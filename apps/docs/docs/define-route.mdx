---
title: "Define Route"
description: "Create type-safe routes with static route or with dynamic parameters."
---

The RPress allows you to define routes with type-safe parameters and static generation configuration. Routes are automatically discovered from your configured routes directory.

## Route Discovery

RPress automatically scans files in your configured directory for route declarations. By default, it scans all files in `src/routes/**`, but you can customize this in your Vite config:

```ts title="vite.config.ts"
import rpress from "rpress/vite";

export default defineConfig({
  plugins: [
    rpress({
      routesDir: "src/routes/**", // Default scan location
    }),
  ],
});
```

### Custom Route Directories

You can scan routes from any directory pattern:

```ts
// Custom routes directory
rpress({
  routesDir: "src/pages/**", // Scan src/pages instead
});

// Multiple patterns
rpress({
  routesDir: "src/{routes,pages}/**", // Scan both directories
});

// Specific subdirectories
rpress({
  routesDir: "app/routes/**", // Scan app/routes
});
```

### Multiple Directories

You can also declare multiple directories to scan for routes:

```ts
// vite.config.ts
rpress({
  routesDir: "src/{routes,pages,components}/**",
});
```

## Route Declaration

### Basic Declaration

Routes are defined by declaring a `route` export in any file within the scanned directories. The file name and location don't determine the URL - only the `createRoute` path does:

```tsx
// Any file in src/routes/** (or your configured directory)
// File: src/routes/my-component.tsx
import { createRoute } from "rpress/route";

export const route = createRoute("/about"); // URL is /about, not /my-component

export default function AboutPage() {
  return <h1>About Us</h1>;
}
```

#### Why we use `createRoute()` to declare routes?

Since routes are declared via `createRoute()` and not determined by file paths, you can organize your files however you prefer,
for example, you can group by feature, keep a flat structure, or use multiple directories.

```files tab="group by feature"
src/routes/
├── auth/
│   ├── login-page.tsx           → createRoute("/login")
│   ├── register-page.tsx        → createRoute("/register")
│   └── profile-page.tsx         → createRoute("/profile")
├── blog/
│   ├── blog-home.tsx           → createRoute("/blog")
│   ├── blog-post.tsx           → createRoute("/blog/:slug")
│   └── blog-category.tsx       → createRoute("/blog/category/:name")
└── shop/
    ├── product-list.tsx        → createRoute("/products")
    ├── product-detail.tsx      → createRoute("/products/:id")
    └── cart.tsx                → createRoute("/cart")
```

```files tab="group by flat structure"
src/routes/
├── home.tsx                    → createRoute("/")
├── about.tsx                   → createRoute("/about")
├── contact.tsx                 → createRoute("/contact")
├── blog-home.tsx              → createRoute("/blog")
├── blog-post.tsx              → createRoute("/blog/:slug")
├── product-list.tsx           → createRoute("/products")
└── product-detail.tsx         → createRoute("/products/:id")
```

RPress will scan all matching files in any of these directories for route declarations, giving you complete flexibility in code organization.

What's more, we don't need generated-type to ensure type safety, which might be **over-engineered**, since `createRoute()` with infer utility `RouterProps` already provides full type inference and safety. We will see how to use it in the examples below.

### Dynamic Routes

Dynamic routes can include parameters in the path using `:name` or `:...name` syntax. You must provide a `generator` function that returns an array of parameter objects for static generation.

For single parameter routes we use `:name` syntax to capture a single segment, like `/blog/:slug`,
then we provide a generator that returns an array of slugs to declare the valid routes, which will be used for static generation:

And in the default export component, we will expose the router React Server

Route Component can only be **Server Component**, this is designed to be intentional to avoid unnecessary client-side JavaScript for routing.

And we can use `RouterProps` to infer the type of `params`, which will be `{ slug: string }` in this case.
RPress will pass the object infer from `"/blog/:slug"` to the `params` prop.
and `RouterProps` is very useful to ensure type safety and get full type inference for route parameters.

The generator function is asynchronous, allowing you to fetch data from an API or database to determine the valid routes.
And you should pass an array of objects, where each object contains the parameters for a specific route.

```tsx
import { createRoute, type RouterProps } from "rpress/route";

export const route = createRoute("/blog/:slug", {
  generator: async () => {
    // you can fetch data from an API or database,
    // or generate routes from your filesystem here.
    return [
      { slug: "first-post" },
      { slug: "second-post" },
      { slug: "third-post" },
    ];
  },
});

export default function BlogPostPage({ params }: RouterProps<typeof route>) {
  return <h1>Blog Post: {params.slug}</h1>;
}
```

#### Catch-All Routes

For routes that need to capture multiple segments, use the `:...name` syntax. The generator should return an array of objects with arrays for the catch-all parameter.
and `RouterProps` will infer the type of `params` as `{ slug: string[] }` in this case.

```tsx
import { createRoute, type RouterProps } from "rpress/route";
export const route = createRoute("/docs/:...slug", {
  generator: async () => {
    // you can fetch data from an API or database,
    // or generate routes from your filesystem here.
    return [
      { slug: ["getting-started"] },
      { slug: ["guides", "installation"] },
      { slug: ["guides", "configuration"] },
    ];
  },
});
```
